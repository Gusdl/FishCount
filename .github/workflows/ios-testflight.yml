name: iOS TestFlight CI (device only)

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  SCHEME: Fischbestand
  PROJECT: Fischbestand.xcodeproj
  TEAM_ID: XDLCKT3P87
  BUNDLE_ID: com.simonmaiwald.fischbestand

jobs:
  build-and-upload:
    runs-on: macos-14

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Select Xcode 16.1
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: "16.1"

      - name: Install XcodeGen
        run: |
          set -euxo pipefail
          brew install xcodegen

      - name: Generate Xcode project from project.yml
        run: |
          set -euxo pipefail
          xcodegen generate
          grep -q "WhisperModelManager.swift" Fischbestand.xcodeproj/project.pbxproj
          grep -q "AppleSpeechBackend.swift" Fischbestand.xcodeproj/project.pbxproj
          grep -q "SpeechBackend.swift" Fischbestand.xcodeproj/project.pbxproj

      # --- Signing: Zertifikat importieren (robust, repackage) ---
      - name: Import signing identity
        env:
          CERT_P12: ${{ secrets.CERT_P12 }}         # base64 der .p12
          P12_PASSWORD: ${{ secrets.P12_PASSWORD }} # Passwort der .p12
        run: |
          set -euxo pipefail
          printf '%s' "$CERT_P12" | base64 --decode > /tmp/orig.p12
          KEYCHAIN="$RUNNER_TEMP/app.keychain-db"
          security create-keychain -p "" "$KEYCHAIN"
          security list-keychains -d user -s "$KEYCHAIN" $(security list-keychains -d user | sed 's/^[ \t]*//')
          security default-keychain -s "$KEYCHAIN"
          security unlock-keychain -p "" "$KEYCHAIN"
          P12_PASS_TRIMMED="$(printf '%s' "$P12_PASSWORD" | tr -d '\r\n')"
          if /usr/bin/openssl pkcs12 -in /tmp/orig.p12 -passin pass:"$P12_PASS_TRIMMED" -nokeys -clcerts -info >/dev/null 2>&1; then
            LEG=0
          else
            LEG=1
          fi
          if [ "$LEG" = "1" ]; then
            /usr/bin/openssl pkcs12 -legacy -in /tmp/orig.p12 -passin pass:"$P12_PASS_TRIMMED" -nodes -nocerts -out /tmp/key.pem
            /usr/bin/openssl pkcs12 -legacy -in /tmp/orig.p12 -passin pass:"$P12_PASS_TRIMMED" -nokeys -out /tmp/cert.pem
          else
            /usr/bin/openssl pkcs12 -in /tmp/orig.p12 -passin pass:"$P12_PASS_TRIMMED" -nodes -nocerts -out /tmp/key.pem
            /usr/bin/openssl pkcs12 -in /tmp/orig.p12 -passin pass:"$P12_PASS_TRIMMED" -nokeys -out /tmp/cert.pem
          fi
          /usr/bin/openssl pkcs12 -export -inkey /tmp/key.pem -in /tmp/cert.pem -out /tmp/fresh.p12 -passout pass:temp123
          security import /tmp/fresh.p12 -k "$KEYCHAIN" -f pkcs12 -P temp123 -A \
            -T /usr/bin/codesign -T /usr/bin/security -T /usr/bin/xcodebuild
          security set-key-partition-list -S apple-tool:,apple: -s -k "" "$KEYCHAIN"
          security find-identity -v -p codesigning "$KEYCHAIN"

      # --- Provisioning Profile installieren + prüfen ---
      - name: Install provisioning profile
        env:
          MOBILEPROVISION: ${{ secrets.MOBILEPROVISION }}  # base64 des App-Store-Profils
        run: |
          set -euxo pipefail
          PP_DIR="$HOME/Library/MobileDevice/Provisioning Profiles"
          mkdir -p "$PP_DIR"
          printf '%s' "$MOBILEPROVISION" | base64 --decode > "$PP_DIR/profile.mobileprovision"
          security cms -D -i "$PP_DIR/profile.mobileprovision" > profile.plist
          PP_UUID=$(/usr/libexec/PlistBuddy -c 'Print :UUID' profile.plist)
          PP_NAME=$(/usr/libexec/PlistBuddy -c 'Print :Name' profile.plist)
          APP_ID=$(/usr/libexec/PlistBuddy -c 'Print :Entitlements:application-identifier' profile.plist)
          GET_TASK_ALLOW=$(/usr/libexec/PlistBuddy -c 'Print :Entitlements:get-task-allow' profile.plist || echo false)
          PP_TEAMID="${APP_ID%%.*}"
          PP_BUNDLEID="${APP_ID#*.}"
          echo "PP_UUID=$PP_UUID" >> $GITHUB_ENV
          echo "PP_NAME=$PP_NAME" >> $GITHUB_ENV
          [ "$GET_TASK_ALLOW" = "false" ] || { echo "::error ::Profil ist kein App-Store-Profil."; exit 1; }
          [ "$PP_TEAMID" = "$TEAM_ID" ] || { echo "::error ::TeamID mismatch: $PP_TEAMID != $TEAM_ID"; exit 1; }
          [ "$PP_BUNDLEID" = "$BUNDLE_ID" ] || { echo "::error ::BundleID mismatch: $PP_BUNDLEID != $BUNDLE_ID"; exit 1; }

      # --- Sanitize: entferne versehentlich kopierte Info.plist aus App-Ressourcen ---
      - name: Sanitize project (remove stray Info.plist from resources)
        run: |
          set -euxo pipefail
          gem install xcodeproj
          ruby - <<'RUBY'
          require 'xcodeproj'
          proj = Xcodeproj::Project.open('Fischbestand.xcodeproj')
          app = proj.targets.find { |t| t.name == 'Fischbestand' }
          rbp = app.resources_build_phase
          removed = 0
          rbp.files.dup.each do |bf|
            ref = bf.file_ref
            next unless ref && ref.path && File.basename(ref.path) == 'Info.plist'
            rbp.remove_build_file(bf); removed += 1
          end
          proj.save
          puts "Removed #{removed} Info.plist from app resources"
          RUBY

      - name: Build (device only, no signing) – sanity check
        run: |
          set -euxo pipefail
          xcodebuild -project "$PROJECT" -scheme "$SCHEME" -configuration Debug \
            -destination 'generic/platform=iOS' -sdk iphoneos \
            CODE_SIGNING_ALLOWED=NO CODE_SIGNING_REQUIRED=NO build

      # --- Archive (nur device, mit Signatur) ---
      - name: Build (device) with full log
        run: |
          set -euxo pipefail
          mkdir -p build
          xcodebuild -project "$PROJECT" -scheme "$SCHEME" -configuration Release \
            -destination 'generic/platform=iOS' -sdk iphoneos \
            -archivePath "$PWD/build/$SCHEME.xcarchive" archive \
            CODE_SIGN_STYLE=Manual \
            DEVELOPMENT_TEAM="$TEAM_ID" \
            PRODUCT_BUNDLE_IDENTIFIER="$BUNDLE_ID" \
            PROVISIONING_PROFILE_SPECIFIER="$PP_NAME" \
            PROVISIONING_PROFILE="$PP_UUID" \
            CODE_SIGN_IDENTITY="Apple Distribution" \
            ASSETCATALOG_COMPILER_APPICON_NAME=AppIcon \
            | tee build/xcodebuild.log

      - uses: actions/upload-artifact@v4
        if: always()
        with:
          name: xcodebuild-log
          path: build/xcodebuild.log

      # --- Export IPA ---
      - name: Export IPA
        run: |
          cat > ExportOptions.plist <<PLIST
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0"><dict>
            <key>method</key><string>app-store</string>
            <key>teamID</key><string>${TEAM_ID}</string>
            <key>uploadSymbols</key><true/>
            <key>stripSwiftSymbols</key><true/>
          </dict></plist>
          PLIST
          xcodebuild -exportArchive \
            -archivePath "$PWD/build/$SCHEME.xcarchive" \
            -exportPath  "$PWD/build" \
            -exportOptionsPlist ExportOptions.plist
          ls -la build

      # --- Fastlane Upload zu TestFlight (API Key, non-interactive) ---
      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.2"
          bundler-cache: true

      - name: Install fastlane
        run: gem install fastlane

      - name: Upload to TestFlight
        env:
          APP_STORE_CONNECT_KEY_ID:     ${{ secrets.ASC_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID:  ${{ secrets.ASC_ISSUER_ID }}
          APP_STORE_CONNECT_API_KEY:    ${{ secrets.ASC_API_KEY_CONTENTS }}
          CI: true
          FASTLANE_DISABLE_COLORS: 1
          FASTLANE_SKIP_UPDATE_CHECK: 1
          FASTLANE_OPT_OUT_USAGE: 1
        run: |
          set -euxo pipefail
          mkdir -p fastlane
          cat > fastlane/Fastfile <<'RUBY'
          opt_out_usage
          default_platform(:ios)
          platform :ios do
            lane :beta do
              api_key = app_store_connect_api_key(
                key_id: ENV["APP_STORE_CONNECT_KEY_ID"],
                issuer_id: ENV["APP_STORE_CONNECT_ISSUER_ID"],
                key_content: ENV["APP_STORE_CONNECT_API_KEY"]
              )
              pilot(api_key: api_key,
                    ipa: "build/#{ENV['SCHEME']}.ipa",
                    skip_waiting_for_build_processing: true)
            end
          end
          RUBY
          test -f "build/${SCHEME}.ipa"
          fastlane ios beta --non-interactive

      # --- Logs als Artefakt (für Diagnose bei Fehlern) ---
      - name: Upload build logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: xcresult
          path: build/Build.xcresult
