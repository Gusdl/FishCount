---
name: iOS TestFlight CI (device only)

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  SCHEME: Fischbestand
  PROJECT: Fischbestand.xcodeproj
  TEAM_ID: XDLCKT3P87
  BUNDLE_ID: com.simonmaiwald.fischbestand

jobs:
  build-and-upload:
    runs-on: macos-14

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Select Xcode 16.1
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: "16.1"

      - name: Install XcodeGen
        run: |
          set -euxo pipefail
          brew install xcodegen

      - name: Generate Xcode project from project.yml
        run: |
          set -euxo pipefail
          rm -rf Fischbestand.xcodeproj
          xcodegen generate
          PBX="Fischbestand.xcodeproj/project.pbxproj"
          for f in \
            Fischbestand/Services/Speech/SpeechBackend.swift \
            Fischbestand/Services/Speech/AppleSpeechBackend.swift \
            Fischbestand/Services/Speech/WhisperBackend.swift \
            Fischbestand/Services/Speech/WhisperModelManager.swift \
          ; do
            test -f "$f" || { echo "::error file=$f::missing file"; exit 1; }
            grep -q "$(basename "$f")" "$PBX" || { echo "::error ::$f not in target sources"; exit 1; }
          done

      - name: Ensure privacy usage descriptions
        run: |
          set -euxo pipefail
          PLIST="Fischbestand/Resources/Info.plist"
          /usr/libexec/PlistBuddy -c "Delete :NSSpeechRecognitionUsageDescription" "$PLIST" 2>/dev/null || true
          /usr/libexec/PlistBuddy -c "Add :NSSpeechRecognitionUsageDescription string 'Wir verwenden Spracherkennung, um gesprochene Zählungen automatisch zu transkribieren.'" "$PLIST"
          /usr/libexec/PlistBuddy -c "Delete :NSMicrophoneUsageDescription" "$PLIST" 2>/dev/null || true
          /usr/libexec/PlistBuddy -c "Add :NSMicrophoneUsageDescription string 'Wir benötigen das Mikrofon, um Ihre Sprachzählungen im Feld aufzunehmen.'" "$PLIST"
          /usr/libexec/PlistBuddy -c "Delete :NSLocationWhenInUseUsageDescription" "$PLIST" 2>/dev/null || true
          /usr/libexec/PlistBuddy -c "Add :NSLocationWhenInUseUsageDescription string 'Wir verwenden Ihren Standort, um den Gewässer-Standort zum Protokoll hinzuzufügen.'" "$PLIST"

      - name: Set unique build number
        run: |
          set -euxo pipefail
          NOW=$(date -u +%Y%m%d%H%M%S)
          MIN_BASE=20251015171655
          RUN_NUMBER=${GITHUB_RUN_NUMBER:-0}
          MINIMUM=$((MIN_BASE + RUN_NUMBER))
          if [ "$NOW" -gt "$MINIMUM" ]; then
            BUILD_NUMBER=$NOW
          else
            BUILD_NUMBER=$MINIMUM
          fi
          echo "::notice ::Using build number $BUILD_NUMBER"
          echo "BUILD_NUMBER=$BUILD_NUMBER" >> $GITHUB_ENV

      - name: Apply build number to project settings
        run: |
          set -euxo pipefail
          rm -rf build
          xcrun agvtool new-version -all "$BUILD_NUMBER"

      # --- Signing: Zertifikat importieren (robust, repackage) ---
      - name: Import signing identity
        env:
          CERT_P12: ${{ secrets.CERT_P12 }}  # base64 der .p12
          P12_PASSWORD: ${{ secrets.P12_PASSWORD }}  # Passwort der .p12
        run: |
          set -euxo pipefail
          printf '%s' "$CERT_P12" | base64 --decode > /tmp/orig.p12
          KEYCHAIN="$RUNNER_TEMP/app.keychain-db"
          security create-keychain -p "" "$KEYCHAIN"
          security list-keychains -d user -s "$KEYCHAIN" $(security list-keychains -d user | sed 's/^[ \t]*//')
          security default-keychain -s "$KEYCHAIN"
          security unlock-keychain -p "" "$KEYCHAIN"
          P12_PASS_TRIMMED="$(printf '%s' "$P12_PASSWORD" | tr -d '\r\n')"
          if /usr/bin/openssl pkcs12 -in /tmp/orig.p12 -passin pass:"$P12_PASS_TRIMMED" -nokeys -clcerts -info >/dev/null 2>&1; then
            LEG=0
          else
            LEG=1
          fi
          if [ "$LEG" = "1" ]; then
            /usr/bin/openssl pkcs12 -legacy -in /tmp/orig.p12 -passin pass:"$P12_PASS_TRIMMED" -nodes -nocerts -out /tmp/key.pem
            /usr/bin/openssl pkcs12 -legacy -in /tmp/orig.p12 -passin pass:"$P12_PASS_TRIMMED" -nokeys -out /tmp/cert.pem
          else
            /usr/bin/openssl pkcs12 -in /tmp/orig.p12 -passin pass:"$P12_PASS_TRIMMED" -nodes -nocerts -out /tmp/key.pem
            /usr/bin/openssl pkcs12 -in /tmp/orig.p12 -passin pass:"$P12_PASS_TRIMMED" -nokeys -out /tmp/cert.pem
          fi
          /usr/bin/openssl pkcs12 -export -inkey /tmp/key.pem -in /tmp/cert.pem -out /tmp/fresh.p12 -passout pass:temp123
          security import /tmp/fresh.p12 -k "$KEYCHAIN" -f pkcs12 -P temp123 -A \
            -T /usr/bin/codesign -T /usr/bin/security -T /usr/bin/xcodebuild
          security set-key-partition-list -S apple-tool:,apple: -s -k "" "$KEYCHAIN"
          security find-identity -v -p codesigning "$KEYCHAIN"
          echo "KEYCHAIN=$KEYCHAIN" >> $GITHUB_ENV

      # --- Provisioning Profile installieren + prüfen ---
      - name: Install provisioning profile
        env:
          MOBILEPROVISION: ${{ secrets.MOBILEPROVISION }}  # base64 des App-Store-Profils
        run: |
          set -euxo pipefail
          PP_DIR="$HOME/Library/MobileDevice/Provisioning Profiles"
          mkdir -p "$PP_DIR"
          printf '%s' "$MOBILEPROVISION" | base64 --decode > "$PP_DIR/profile.mobileprovision"
          security cms -D -i "$PP_DIR/profile.mobileprovision" > profile.plist
          PP_UUID=$(/usr/libexec/PlistBuddy -c 'Print :UUID' profile.plist)
          PP_NAME=$(/usr/libexec/PlistBuddy -c 'Print :Name' profile.plist)
          APP_ID=$(/usr/libexec/PlistBuddy -c 'Print :Entitlements:application-identifier' profile.plist)
          GET_TASK_ALLOW=$(/usr/libexec/PlistBuddy -c 'Print :Entitlements:get-task-allow' profile.plist || echo false)
          PP_TEAMID="${APP_ID%%.*}"
          PP_BUNDLEID="${APP_ID#*.}"
          echo "PP_UUID=$PP_UUID" >> $GITHUB_ENV
          echo "PP_NAME=$PP_NAME" >> $GITHUB_ENV
          [ "$GET_TASK_ALLOW" = "false" ] || { echo "::error ::Profil ist kein App-Store-Profil."; exit 1; }
          [ "$PP_TEAMID" = "$TEAM_ID" ] || { echo "::error ::TeamID mismatch: $PP_TEAMID != $TEAM_ID"; exit 1; }
          [ "$PP_BUNDLEID" = "$BUNDLE_ID" ] || { echo "::error ::BundleID mismatch: $PP_BUNDLEID != $BUNDLE_ID"; exit 1; }

      # --- Sanitize: entferne versehentlich kopierte Info.plist aus App-Ressourcen ---
      - name: Sanitize project (remove stray Info.plist from resources)
        run: |
          set -euxo pipefail
          gem install xcodeproj
          ruby - <<'RUBY'
          require 'xcodeproj'
          proj = Xcodeproj::Project.open('Fischbestand.xcodeproj')
          app = proj.targets.find { |t| t.name == 'Fischbestand' }
          rbp = app.resources_build_phase
          removed = 0
          rbp.files.dup.each do |bf|
            ref = bf.file_ref
            next unless ref && ref.path && File.basename(ref.path) == 'Info.plist'
            rbp.remove_build_file(bf); removed += 1
          end
          proj.save
          puts "Removed #{removed} Info.plist from app resources"
          RUBY

      - name: Preflight (list targets and schemes)
        run: |
          set -euxo pipefail
          xcodebuild -list -project "$PROJECT"

      # --- Build (nur device, ohne Signatur) – Sanity Check ---
      - name: Build (device only, no signing) – sanity check
        run: |
          set -euxo pipefail
          mkdir -p build
          xcodebuild -project "$PROJECT" -scheme "$SCHEME" -configuration Debug \
            -destination 'generic/platform=iOS' -sdk iphoneos \
            CODE_SIGNING_ALLOWED=NO CODE_SIGNING_REQUIRED=NO \
            CURRENT_PROJECT_VERSION="$BUILD_NUMBER" \
            build \
            | tee build/first-build.log

      - uses: actions/upload-artifact@v4
        if: always()
        with:
          name: first-build-log
          path: build/first-build.log

      # --- Archive (nur device, mit Signatur) ---
      - name: Build (device) with full log
        run: |
          set -euxo pipefail
          mkdir -p build
          xcodebuild -project "$PROJECT" -scheme "$SCHEME" -configuration Release \
            -destination 'generic/platform=iOS' -sdk iphoneos \
            -archivePath "$PWD/build/$SCHEME.xcarchive" \
            archive \
            CODE_SIGN_STYLE=Manual \
            DEVELOPMENT_TEAM="$TEAM_ID" \
            PRODUCT_BUNDLE_IDENTIFIER="$BUNDLE_ID" \
            PROVISIONING_PROFILE_SPECIFIER="$PP_NAME" \
            PROVISIONING_PROFILE="$PP_UUID" \
            OTHER_CODE_SIGN_FLAGS="--keychain $KEYCHAIN" \
            CURRENT_PROJECT_VERSION="$BUILD_NUMBER" \
            ASSETCATALOG_COMPILER_APPICON_NAME=AppIcon \
            | tee build/xcodebuild.log

      - uses: actions/upload-artifact@v4
        if: always()
        with:
          name: xcodebuild-log
          path: build/xcodebuild.log

      # --- Export IPA ---
      - name: Export IPA
        run: |
          cat > ExportOptions.plist <<PLIST
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0"><dict>
            <key>method</key><string>app-store</string>
            <key>teamID</key><string>${TEAM_ID}</string>
            <key>signingStyle</key><string>manual</string>
            <key>signingCertificate</key><string>Apple Distribution</string>
            <key>provisioningProfiles</key>
            <dict>
              <key>${BUNDLE_ID}</key><string>${PP_NAME}</string>
            </dict>
            <key>uploadSymbols</key><true/>
            <key>stripSwiftSymbols</key><true/>
          </dict></plist>
          PLIST
          xcodebuild -exportArchive \
            -archivePath "$PWD/build/$SCHEME.xcarchive" \
            -exportPath  "$PWD/build" \
            -exportOptionsPlist ExportOptions.plist \
            -allowProvisioningUpdates
          ls -la build

      # --- Fastlane Upload zu TestFlight (API Key, non-interactive) ---
      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.2"
          bundler-cache: true

      - name: Install fastlane
        run: gem install fastlane

      - name: Upload to TestFlight
        env:
          APP_STORE_CONNECT_KEY_ID: ${{ secrets.ASC_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.ASC_ISSUER_ID }}
          APP_STORE_CONNECT_API_KEY: ${{ secrets.ASC_API_KEY_CONTENTS }}
          CI: true
          FASTLANE_DISABLE_COLORS: 1
          FASTLANE_SKIP_UPDATE_CHECK: 1
          FASTLANE_OPT_OUT_USAGE: 1
          FASTLANE_SKIP_CONFIRMATION: 1
        run: |
          set -euxo pipefail
          mkdir -p fastlane
          cat > fastlane/Fastfile <<'RUBY'
          opt_out_usage
          default_platform(:ios)
          platform :ios do
            lane :beta do
              api_key = app_store_connect_api_key(
                key_id: ENV["APP_STORE_CONNECT_KEY_ID"],
                issuer_id: ENV["APP_STORE_CONNECT_ISSUER_ID"],
                key_content: ENV["APP_STORE_CONNECT_API_KEY"]
              )
              pilot(api_key: api_key,
                    ipa: "build/#{ENV['SCHEME']}.ipa",
                    build_number: ENV['BUILD_NUMBER'],
                    skip_waiting_for_build_processing: true)
            end
          end
          RUBY
          test -f "build/${SCHEME}.ipa"
          fastlane ios beta

      # --- Logs als Artefakt (für Diagnose bei Fehlern) ---
      - name: Upload build logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: xcresult
          path: build/Build.xcresult
