name: iOS TestFlight CI

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  SCHEME: Fischbestand
  TEAM_ID: XDLCKT3P87
  BUNDLE_ID: com.simonmaiwald.fischbestand

jobs:
  build-and-upload:
    runs-on: macos-14

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Select Xcode 15.4
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: "15.4"

      - name: Ensure AppIcon exists (placeholder, safe)
        run: |
          set -euxo pipefail
          ICONSET="Fischbestand/Resources/Assets.xcassets/AppIcon.appiconset"
          mkdir -p "$ICONSET"
          printf '%s' iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMB/UZz3QAAAABJRU5ErkJggg== | base64 -d > "$ICONSET/_base.png"
          /usr/bin/sips -s format png --resampleWidth 1024 "$ICONSET/_base.png" --out "$ICONSET/Icon-1024.png"
          for size in 20 29 40 60; do
            for scale in 2 3; do
              px=$((size*scale))
              /usr/bin/sips -s format png --resampleWidth "$px" "$ICONSET/Icon-1024.png" --out "$ICONSET/Icon-iphone-${size}x${size}@${scale}x.png"
            done
          done
          /usr/bin/python3 - <<'PY'
          import json, os
          iconset="Fischbestand/Resources/Assets.xcassets/AppIcon.appiconset"
          images=[
            {"idiom":"iphone","size":"20x20","scale":"2x","filename":"Icon-iphone-20x20@2x.png"},
            {"idiom":"iphone","size":"20x20","scale":"3x","filename":"Icon-iphone-20x20@3x.png"},
            {"idiom":"iphone","size":"29x29","scale":"2x","filename":"Icon-iphone-29x29@2x.png"},
            {"idiom":"iphone","size":"29x29","scale":"3x","filename":"Icon-iphone-29x29@3x.png"},
            {"idiom":"iphone","size":"40x40","scale":"2x","filename":"Icon-iphone-40x40@2x.png"},
            {"idiom":"iphone","size":"40x40","scale":"3x","filename":"Icon-iphone-40x40@3x.png"},
            {"idiom":"iphone","size":"60x60","scale":"2x","filename":"Icon-iphone-60x60@2x.png"},
            {"idiom":"iphone","size":"60x60","scale":"3x","filename":"Icon-iphone-60x60@3x.png"},
            {"idiom":"ios-marketing","size":"1024x1024","scale":"1x","filename":"Icon-1024.png"},
          ]
          data={"images":images,"info":{"version":1,"author":"xcode"}}
          with open(os.path.join(iconset,"Contents.json"),"w") as f: json.dump(data,f,indent=2)
          PY

      - name: Install certificates (triple fallback, rock solid)
        env:
          P12_BASE64: ${{ secrets.CERT_P12 }}
          P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
        run: |
          set -euxo pipefail
          printf '%s' "$P12_BASE64" | base64 --decode > cert.p12

          KEYCHAIN=$RUNNER_TEMP/app.keychain-db
          security create-keychain -p "" "$KEYCHAIN"
          security default-keychain -s "$KEYCHAIN"
          security unlock-keychain -p "" "$KEYCHAIN"

          if ! openssl pkcs12 -in cert.p12 -passin pass:"$P12_PASSWORD" -nokeys -clcerts -info >/dev/null 2>&1; then
            LEGACY=1
          else
            LEGACY=0
          fi

          if [ "$LEGACY" = "1" ]; then
            openssl pkcs12 -legacy -in cert.p12 -passin pass:"$P12_PASSWORD" -nodes -nocerts -out key.pem
            openssl pkcs12 -legacy -in cert.p12 -passin pass:"$P12_PASSWORD" -nokeys -out cert.pem
          else
            openssl pkcs12 -in cert.p12 -passin pass:"$P12_PASSWORD" -nodes -nocerts -out key.pem
            openssl pkcs12 -in cert.p12 -passin pass:"$P12_PASSWORD" -nokeys -out cert.pem
          fi

          security import cert.pem -A -t cert -k "$KEYCHAIN"

          if security import key.pem -k "$KEYCHAIN" -t priv -f openssl -A \
               -T /usr/bin/codesign -T /usr/bin/security -T /usr/bin/xcodebuild ; then
            echo "Imported private key as OpenSSL PEM."
          else
            echo "OpenSSL PEM import failed, trying PKCS#8 DER…"
            openssl pkcs8 -topk8 -nocrypt -in key.pem -outform DER -out key-pkcs8.der
            if security import key-pkcs8.der -k "$KEYCHAIN" -t priv -f pkcs8 -A \
                 -T /usr/bin/codesign -T /usr/bin/security -T /usr/bin/xcodebuild ; then
              echo "Imported private key as PKCS#8 DER."
            else
              echo "PKCS#8 DER import failed, repack to fresh PKCS#12…"
              openssl pkcs12 -export -inkey key.pem -in cert.pem -out fresh.p12 -passout pass:temp123
              security import fresh.p12 -P temp123 -k "$KEYCHAIN" -A -t agg
              echo "Imported key via fresh PKCS#12."
            fi
          fi

          security set-key-partition-list -S apple-tool:,apple: -s -k "" "$KEYCHAIN"

      - name: Install provisioning profile + extract metadata
        env:
          MOBILEPROVISION_BASE64: ${{ secrets.MOBILEPROVISION }}
        run: |
          set -euxo pipefail
          PP_DIR="$HOME/Library/MobileDevice/Provisioning Profiles"
          mkdir -p "$PP_DIR"
          printf '%s' "$MOBILEPROVISION_BASE64" | base64 --decode > "$PP_DIR/profile.mobileprovision"

          /usr/bin/security cms -D -i "$PP_DIR/profile.mobileprovision" > profile.plist
          PP_UUID=$(/usr/libexec/PlistBuddy -c 'Print :UUID' profile.plist)
          PP_NAME=$(/usr/libexec/PlistBuddy -c 'Print :Name' profile.plist)
          APP_ID=$(/usr/libexec/PlistBuddy -c 'Print :Entitlements:application-identifier' profile.plist)
          PP_TEAMID="${APP_ID%%.*}"
          PP_BUNDLEID="${APP_ID#*.}"
          GET_TASK_ALLOW=$(/usr/libexec/PlistBuddy -c 'Print :Entitlements:get-task-allow' profile.plist || echo false)

          echo "PP_UUID=$PP_UUID" | tee -a $GITHUB_ENV
          echo "PP_NAME=$PP_NAME" | tee -a $GITHUB_ENV
          echo "PP_TEAMID=$PP_TEAMID" | tee -a $GITHUB_ENV
          echo "PP_BUNDLEID=$PP_BUNDLEID" | tee -a $GITHUB_ENV
          echo "GET_TASK_ALLOW=$GET_TASK_ALLOW" | tee -a $GITHUB_ENV

          if [ "$GET_TASK_ALLOW" != "false" ]; then
            echo "::error ::Du nutzt ein Development/AdHoc Profil. Für App-Store-Archive brauchst du ein DISTRIBUTION (App Store) Profil."
            exit 1
          fi
          if [ "$PP_BUNDLEID" != "${BUNDLE_ID}" ]; then
            echo "::error ::Bundle ID im Profil ($PP_BUNDLEID) passt nicht zu BUNDLE_ID (${BUNDLE_ID})."
            exit 1
          fi
          if [ "$PP_TEAMID" != "${TEAM_ID}" ]; then
            echo "::error ::TeamID im Profil ($PP_TEAMID) passt nicht zu TEAM_ID (${TEAM_ID})."
            exit 1
          fi

      - name: Archive (device, Release, manual signing)
        run: |
          set -euxo pipefail
          xcodebuild \
            -scheme "$SCHEME" \
            -configuration Release \
            -destination 'generic/platform=iOS' \
            -sdk iphoneos \
            -archivePath "$PWD/build/$SCHEME.xcarchive" \
            archive \
            CODE_SIGN_STYLE=Manual \
            DEVELOPMENT_TEAM="${TEAM_ID}" \
            PRODUCT_BUNDLE_IDENTIFIER="${BUNDLE_ID}" \
            PROVISIONING_PROFILE_SPECIFIER="${PP_NAME}" \
            PROVISIONING_PROFILE="${PP_UUID}" \
            CODE_SIGN_IDENTITY="Apple Distribution" \
            ASSETCATALOG_COMPILER_APPICON_NAME=AppIcon \
            TARGETED_DEVICE_FAMILY=1

      - name: Export IPA
        run: |
          cat > ExportOptions.plist <<PLIST
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0"><dict>
            <key>method</key><string>app-store-connect</string>
            <key>teamID</key><string>${TEAM_ID}</string>
            <key>uploadSymbols</key><true/>
            <key>stripSwiftSymbols</key><true/>
            <key>destination</key><string>export</string>
            <key>signingStyle</key><string>manual</string>
            <key>signingCertificate</key><string>Apple Distribution</string>
            <key>provisioningProfiles</key>
            <dict>
              <key>${BUNDLE_ID}</key><string>${PP_NAME}</string>
            </dict>
          </dict></plist>
          PLIST
          xcodebuild -exportArchive \
            -archivePath "$PWD/build/$SCHEME.xcarchive" \
            -exportPath  "$PWD/build" \
            -exportOptionsPlist ExportOptions.plist
          ls -la build

      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2'
          bundler-cache: true

      - name: Install fastlane
        run: gem install fastlane

      - name: Upload to TestFlight (non-interactive)
        env:
          APP_STORE_CONNECT_KEY_ID:     ${{ secrets.ASC_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID:  ${{ secrets.ASC_ISSUER_ID }}
          APP_STORE_CONNECT_API_KEY:    ${{ secrets.ASC_API_KEY_CONTENTS }}
          CI: true
          FASTLANE_DISABLE_COLORS: 1
          FASTLANE_SKIP_UPDATE_CHECK: 1
          FASTLANE_OPT_OUT_USAGE: 1
        run: |
          set -euxo pipefail

          # Sicherstellen, dass die IPA da ist
          ls -la build || true
          test -f "build/${SCHEME}.ipa" || { echo "::error::IPA fehlt unter build/${SCHEME}.ipa"; exit 1; }

          # Fastfile im standard Pfad anlegen (fastlane/Fastfile)
          mkdir -p fastlane
          cat > fastlane/Fastfile <<'RUBY'
          opt_out_usage
          default_platform(:ios)
          platform :ios do
            lane :beta do
              api_key = app_store_connect_api_key(
                key_id: ENV["APP_STORE_CONNECT_KEY_ID"],
                issuer_id: ENV["APP_STORE_CONNECT_ISSUER_ID"],
                key_content: ENV["APP_STORE_CONNECT_API_KEY"]
              )
              pilot(
                api_key: api_key,
                ipa: "build/#{ENV['SCHEME']}.ipa",
                skip_waiting_for_build_processing: true
              )
            end
          end
          RUBY

          # Non-interactive aufrufen
          fastlane ios beta --non-interactive
